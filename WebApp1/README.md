# WebApp1
### Randy Powell
### Capitol Technology University
### CT 406
### Homework 6: Authentication example 1
### URL OF SITE: not currently hosted

### Description
This app is the result of following the identity tutorials at
* https://docs.microsoft.com/en-us/aspnet/core/security/authentication/identity?view=aspnetcore-2.1&tabs=visual-studio
* https://docs.microsoft.com/en-us/aspnet/core/security/authorization/secure-data?view=aspnetcore-2.1

At the basic level, the app tracks a public contact list with different permissions for different types of users. Basic users can submit, view, edit, and delete their own contacts and view approved contacts. Manager users can create, edit, and delete their own contacts. Managers can also view any contact and designate them as approved or rejected. Admin users can view, edit, delete, or change the state of any contact. 

Following the first tutorial, this app implements dotnet identity, allowing users to create accounts, log in, and log out. Identity is added to the app in ` Startup.cs ` under ` ConfigureServices ` with ` AddIdentity `. All identity files are scaffolded and contained under ` Areas/Identity `. 
Login pages are generated in the Pages folder for denying access, confirm email, forgot password, lockout, login, logout, reset password. A set of account management pages are also generated for changing passwords, deleting personal data, setting password, and more.
Pages can be privatized and require a user to log in by inserting ` [Authorize] ` in the page cs file. In this app, we require authentication by default and only indicate when pages should be accessible anonymously.

The actual app portion, under ` Pages/Contact `, is only viewable if users are logged in. If a user is not logged in, he can only access the home, contact, and about pages. By default, anonymous access is turned off for all pages. This is done in ` startup.cs ` with ` .RequireAuthenticatedUser() `. Some pages allow anonymous access with ` [AllowAnonymous] ` in their cs file.
The actual app uses authorization for certain actions, allowing only users in certain roles to perform some actions. Roles are added to services using ` .AddIdentity<IdentityUser, IdentityRole>() `. This is different from the method in the tutorial because the tutorial method causes the ` isInRole ` method to break in ASP.NET Core 2.1. Each type of user has an authorization handler in the Authorization folder to set out what permissions each type of user has in the app. 
Each page in the Pages/Contacts folder uses these handlers to decide which actions are accessible for the user. 
For example, ' Index.cshtml.cs ' tests if a user is authenticated to view every contact by calling ' isInRole ' for managers and administrators. 
If the user is in neither of these roles, the program cuts down the contacts to ones where the the user is the owner or the contact is approved.

### Questions
1. Pick a vulnerability from the OWASP Top Ten (2017 edition is preferable) that we have not discussed in class. Explain it and how to use ASP.NET Core utilities to prevent it.

A5-2017: Broken Access Control:

Broken access control happens when sensitive data or actions of an app are not properly protected from users who are not authorized.
Attackers have tools to detect the absence of access control and can breach systems and act as users or administrators to use privileged functions. They can then sometimes create, access, update, or delete every record in the database.
.NET Core has strict authentication tools to prevent this. In our app, each page was automatically restricted to users with accounts on the app by ddfault and forced users to register accounts to access them. The data was protected so only users in the administrator or manager roles could see every entry and change the state of a contact and only administrators could edit and delete any entry.

2. Explain how passwords are stored in ASP.NET Core and how this relates to the concept of "Cryptographic Agility".

Passwords in ASP.NET core are stored in the database as hashes which are generated by using the sign in manager interface provided by ASP.NET Core. The actual methods of storing the passwords are decoupled from the app using dependency injection. These methods are completely separated from the logic of the app. This plays very wwell into the idea of cryptographic agility, which entails apps being built to easily evolve and adopt alternative methods of cryptography to what was originally designed. Using dependency injection makes it very easy for the password hashing to evolve to changing needs. Since the methods are native to ASP.NET Core, they can change and evolve without any effort by the local developer when new versions are released.

3. The Microsoft.AspNetCore.Identity defines the following domain classes. Please explain each:

IdentityRole - Defines a role, or type of user, in the identity system. Allows users to have different capabilities depending on what kind of user they are.

IdentityUserRole - Defines a link between a user and a role. Allows user to be assigned to a role defined by IdentityRole.

IdentityUserClaim - Defines a link between a user and a claim directly. Authorizes specific users to have certain permissions defined in the claim. Used to allow specific users to have specific permissions.

IdentityUserLogin - Represents a login for a user. Allows a user to login to the app.

IdentityUserToken - Represents an authentication token linked to a user. Stores a user's token, which is used to authenticate the user for different actions.

IdentityRoleClaim  - Defines a link between a role and a claim. Authorizes all users or a specific type to have certain permissions defined in the claim. Used to allow a type of user to have specific permissions.

